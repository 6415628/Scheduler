Quintiq file version 2.0
#parent: #root
StaticMethod StrategySimple (POAAlgorithm poa, SettingsProgramPOACombiLeg parameters, String name_logfile)
{
  TextBody:
  [*
    strategy := poa.Strategy();
    
    // -------------------------------------------------------------------------- //
    // Strategy for dependent path problems, for example scheduling problems      //
    // -------------------------------------------------------------------------- //
    
    // ----- Parameters for the strategy -----
    // The total duration of iteratively improving the solution in this strategy.
    // This does not include the time spend on creating and improving an initial
    // solution. More time spend on iterive improvement will give a higher chance
    // on better results.
    iterativeduration := parameters.TimeLimit();
    
    // The number of threads used throughout the strategy execution. The threads
    // are all busy from begin till end.
    nrthreads := parameters.NrOfThreads();
    
    // ----- Advanced Parameters for the strategy -----
    // We use an adaptive population, so we do not set the MaxPopulation or MaxPathPopulation
    strategy.PlanStrategy().AdaptivePopulation( true );
    
    // After planning every node we propagate to check if this is the best position
    randomconstructiongroupsize := 1;
    
    // The duration between logging information during the iterative strategy
    durationbetweeniterativereports := Duration::Seconds( 1 )
    // Log file name prefix. '' means no logging
    logfilename := 'POASequencing_';
    // Toggle info statements
    
    isprintinfo := true;
    
    // -------------------------------------------------------------------------- //
    // Print parameter values and initial score                                   //
    // -------------------------------------------------------------------------- //
    
    if ( isprintinfo )
    {
     info( 'parameter iterativeduration =' , iterativeduration );
     info( 'parameter nrthreads =' , nrthreads );
     info( 'parameter randomconstructiongroupsize =' , randomconstructiongroupsize );
     info( 'parameter logfilename =' , logfilename );
     info( 'initial score', strategy.BestSolution().TotalScore());
     info( 'Nr Nodes:', poa.PlanElements( relsize ) );
     info( 'Nr Path:', poa.PathTypes( relsize ) );
    }
    
    // -------------------------------------------------------------------------- //
    // Initialize general settings                                                //
    // -------------------------------------------------------------------------- //
    
    // For all constraints change MaxDownStreamDepth to MaxNumber where applicable.
    // For independent path problems MaxNumber gives generally the best results.
    {
      maxdepth := Number::MaxNumber();
      SuboptimizerPOACombiLeg::SetMaxDownstreamDepth( poa, maxdepth, isprintinfo );
    }
    
    // -------------------------------------------------------------------------- //
    // Iterative Strategy                                                         //
    // -------------------------------------------------------------------------- //
    //
    // iterativestrategy will repeatedly run on the start solution generated by
    // initialstrategy.
    
    iterativestrategy := strategy.NewMetaStrategy( 'iterativestrategy' );
    if ( logfilename <> '' )
    {
     iterativestrategy.LogFileName( logfilename + name_logfile + '.log', false );
    }
    
    // The only step used in the iterative strategy.
    iterativestep := iterativestrategy.NewStep( 'iterativestep' );
    // Room for one start solution.
    iterativestep.StartSolutionPool().Capacity( nrthreads );
    
    // Use the current solution as the starting solution for n threads
    n := parameters.NrOfThreadsStartSolution();
    nrfromstartsolution := minvalue( n, nrthreads - 1 );
    for( i := 1; i <= nrfromstartsolution; i++)
    {
      iterativestep.StartSolutionPool().Add( poa.Solution() );
    }
    
    // Destruct all planned nodes to create an empty solution
    destructall := strategy.NewActions( 'DestructAll' );
    randomdestruction := destructall.NewRandomDestruction();
    randomdestruction.Nodes( Number::MaxNumber() );
    randomdestruction.CheckForBetterSolution( false );
    randomdestruction.CheckForBetterSolutionEveryStep( false );
    // Destruct in 1 iteration in at most 100s
    destructall.Execute( 1, 100 );
    
    // While n threads will start from the starting solution
    // The remaining threads will start from an empty plan
    nrfromempty := nrthreads - nrfromstartsolution;
    for( i := 1; i <= nrfromempty; i++ )
    {
     iterativestep.StartSolutionPool().Add( strategy.CurrentSolution() );
    }
    
    // The step is repeated a number of times equal to the number of threads, each
    // time starting from the same initial solution. Each repetition is carried out
    // by its own thread.
    iterativestep.Repetitions( 1 );
    // There is no limit on the number of times this step starts again within a
    // single thread.
    iterativestep.MaximumIterationsActions( Number::MaxNumber() );
    
    // The result of each thread is stored.
    iterativestep.ResultSolutionPool().Capacity( nrthreads );
    
    actions := iterativestep.Actions();
    
    // Use random destruction, which choses randomly a number of planned elements
    // to be destructed.
    randomdestr := actions.NewRandomDestruction();
    
    randomdestr.ExecutionChance().Set( 1.0 );
    
    // Use random construction, which
    // (1) chooses a number of unplanned elements.
    // (2) determines the best move for each element by making estimates for that
    //     move and propagating the moves that make it in the population.
    // (3) carry out the move of the element that was best
    randomcons := actions.NewRandomConstruction();
    // Set the number of unplanned elements to consider.
    randomcons.GroupSize( randomconstructiongroupsize );
    
    //snapshot - do not allow POA to move away from the local optimum by (temporarily) accepting worse solutions
    imprSnapshot := actions.NewSnapshot();
    imprSnapshot.AcceptPercentage().Set( 0.0 );
    imprSnapshot.OverwritePercentage().Set( 0.0 );
    imprSnapshot.OverwriteChance().Set( 0.0 );
    imprSnapshot.ExecutionChance().Set( 1.0 );
    
    // Keep executing the iterative meta strategy until the time limit is reached
    iterativeendtime := DateTime::ActualTime() + iterativeduration;
    lastreporttime := DateTime::ActualTime() - durationbetweeniterativereports;
    
    continue := true;
    
    while( continue and DateTime::ActualTime() < iterativeendtime )
    {
     if( isprintinfo )
     {
       info( "POA start solutions:" );
       traverse( iterativestep.StartSolutionPool(), Solutions, solution )
       {
         info( '-' + [String]solution.ThreadNr() + ' :', solution.TotalScore() )
       }
     }
     randomdestr.Nodes( parameters.NrOfNodesForDestruction() );
     executeduration := iterativeendtime - DateTime::ActualTime();
    
    
     // Call meta strategy execution
     iterativestrategy.Execute( nrthreads, executeduration.MinutesAsReal() * 60.0 );
     iterativestep.StartSolutionPool().UseSolutions();
    
     // Fill start solution from the previous iterative step
     usesolution := iterativestep.ResultSolutionPool().UseSolutions();
     // The sorting is required to keep the original thread nr allocation (used later for reporting which start solution found the improvement in the snapshot)
     solutions := selectsortedset(usesolution, Solutions, solution, true, solution.ThreadNr() );
     traverse( solutions, Elements, solution )
     {
       iterativestep.StartSolutionPool().Add( solution );
     }
    
     //continue iteration as long as there is improvement
     continue := actions.IterationsImproved().Value() > 0;
    
     if( DateTime::ActualTime() - lastreporttime >= durationbetweeniterativereports )
     {
       lastreporttime := DateTime::ActualTime();
       if( isprintinfo )
       {
       i := 0;
       total := 0.0;
       best := 10000000.0;
    
         solutions := selectsortedset( iterativestep.StartSolutionPool(), Solutions, s, true, s.ThreadNr() ); 
         traverse( solutions, Elements, s )
         {
            info( s.ThreadNr(), ': iterative result solution score', s.TotalScore().Round( 2 ),
                  'goal:', s.Score().TotalGoalScore().Round( 2 ),
                  'const:', s.Score().TotalConstraintScore().Round( 2 ),
                  'unplan:', s.Score().UnplannedNodeCosts().Round( 2 ),
                  'iterations:', actions.Iterations().Value(),
                  'improvements:', actions.IterationsImproved().Value() );
      
           total := total + s.Score().TotalScore();
           if (s.Score().TotalScore() < best)
           {
             best := s.Score().TotalScore();
           }
           i++;
         }
    
       debuginfo( 'Iterative time remaining =', iterativeendtime - DateTime::ActualTime(),
                  '  Iterations =', actions.Iterations().Value(),
                  '  Improvement =', actions.IterationsImproved().Value(),
                  '  Average =', guard( total / i, 0.0 ).Round( 0 ),
                  '  Best =', best.Round( 0 ),
                  '  Nodes =', randomdestr.Nodes() );
        }
        // After logging reset statistics for the next iteration
        actions.ResetStatistics();
      }
    }
  *]
  InterfaceProperties { Accessibility: 'Module' }
}
